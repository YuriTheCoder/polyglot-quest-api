/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.CompleteTask200Response
import org.openapitools.client.models.CreateTask201Response
import org.openapitools.client.models.CreateTaskRequest
import org.openapitools.client.models.DeleteTask200Response
import org.openapitools.client.models.Error
import org.openapitools.client.models.GetTaskById200Response
import org.openapitools.client.models.GetTaskStats200Response
import org.openapitools.client.models.ListTasks200Response
import org.openapitools.client.models.ListTasksByStatus200Response
import org.openapitools.client.models.UpdateTask200Response
import org.openapitools.client.models.UpdateTaskRequest

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class TasksApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3000")
        }
    }

    /**
     * PATCH /api/tasks/{id}/complete
     * Mark a task as complete
     * 
     * @param id ID da tarefa
     * @return CompleteTask200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun completeTask(id: kotlin.String) : CompleteTask200Response {
        val localVarResponse = completeTaskWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CompleteTask200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/tasks/{id}/complete
     * Mark a task as complete
     * 
     * @param id ID da tarefa
     * @return ApiResponse<CompleteTask200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun completeTaskWithHttpInfo(id: kotlin.String) : ApiResponse<CompleteTask200Response?> {
        val localVariableConfig = completeTaskRequestConfig(id = id)

        return request<Unit, CompleteTask200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation completeTask
     *
     * @param id ID da tarefa
     * @return RequestConfig
     */
    fun completeTaskRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/tasks/{id}/complete".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/tasks
     * Create a new task
     * 
     * @param createTaskRequest 
     * @return CreateTask201Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createTask(createTaskRequest: CreateTaskRequest) : CreateTask201Response {
        val localVarResponse = createTaskWithHttpInfo(createTaskRequest = createTaskRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateTask201Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/tasks
     * Create a new task
     * 
     * @param createTaskRequest 
     * @return ApiResponse<CreateTask201Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createTaskWithHttpInfo(createTaskRequest: CreateTaskRequest) : ApiResponse<CreateTask201Response?> {
        val localVariableConfig = createTaskRequestConfig(createTaskRequest = createTaskRequest)

        return request<CreateTaskRequest, CreateTask201Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createTask
     *
     * @param createTaskRequest 
     * @return RequestConfig
     */
    fun createTaskRequestConfig(createTaskRequest: CreateTaskRequest) : RequestConfig<CreateTaskRequest> {
        val localVariableBody = createTaskRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/tasks/{id}
     * Delete a task
     * 
     * @param id ID da tarefa
     * @return DeleteTask200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTask(id: kotlin.String) : DeleteTask200Response {
        val localVarResponse = deleteTaskWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteTask200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/tasks/{id}
     * Delete a task
     * 
     * @param id ID da tarefa
     * @return ApiResponse<DeleteTask200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTaskWithHttpInfo(id: kotlin.String) : ApiResponse<DeleteTask200Response?> {
        val localVariableConfig = deleteTaskRequestConfig(id = id)

        return request<Unit, DeleteTask200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTask
     *
     * @param id ID da tarefa
     * @return RequestConfig
     */
    fun deleteTaskRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/tasks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/tasks/{id}
     * Get a specific task by ID
     * 
     * @param id ID da tarefa
     * @return GetTaskById200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTaskById(id: kotlin.String) : GetTaskById200Response {
        val localVarResponse = getTaskByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTaskById200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/tasks/{id}
     * Get a specific task by ID
     * 
     * @param id ID da tarefa
     * @return ApiResponse<GetTaskById200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTaskByIdWithHttpInfo(id: kotlin.String) : ApiResponse<GetTaskById200Response?> {
        val localVariableConfig = getTaskByIdRequestConfig(id = id)

        return request<Unit, GetTaskById200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTaskById
     *
     * @param id ID da tarefa
     * @return RequestConfig
     */
    fun getTaskByIdRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/tasks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/tasks/stats
     * Get task statistics
     * 
     * @return GetTaskStats200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTaskStats() : GetTaskStats200Response {
        val localVarResponse = getTaskStatsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTaskStats200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/tasks/stats
     * Get task statistics
     * 
     * @return ApiResponse<GetTaskStats200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTaskStatsWithHttpInfo() : ApiResponse<GetTaskStats200Response?> {
        val localVariableConfig = getTaskStatsRequestConfig()

        return request<Unit, GetTaskStats200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTaskStats
     *
     * @return RequestConfig
     */
    fun getTaskStatsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/tasks/stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter status
     */
     enum class StatusListTasks(val value: kotlin.String) {
         @Json(name = "pending") pending("pending"),
         @Json(name = "in_progress") in_progress("in_progress"),
         @Json(name = "completed") completed("completed");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter priority
     */
     enum class PriorityListTasks(val value: kotlin.String) {
         @Json(name = "low") low("low"),
         @Json(name = "medium") medium("medium"),
         @Json(name = "high") high("high");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortBy
     */
     enum class SortByListTasks(val value: kotlin.String) {
         @Json(name = "createdAt") createdAt("createdAt"),
         @Json(name = "updatedAt") updatedAt("updatedAt"),
         @Json(name = "dueDate") dueDate("dueDate"),
         @Json(name = "priority") priority("priority"),
         @Json(name = "title") title("title");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrderListTasks(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /api/tasks
     * Get all tasks for the logged-in user
     * 
     * @param status Filtrar por status (optional)
     * @param priority Filtrar por prioridade (optional)
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @param sortBy Campo para ordenação (optional, default to createdAt)
     * @param sortOrder Ordem da classificação (optional, default to desc)
     * @param search Buscar no título e descrição (optional)
     * @return ListTasks200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTasks(status: StatusListTasks? = null, priority: PriorityListTasks? = null, page: kotlin.Int? = 1, limit: kotlin.Int? = 10, sortBy: SortByListTasks? = SortByListTasks.createdAt, sortOrder: SortOrderListTasks? = SortOrderListTasks.desc, search: kotlin.String? = null) : ListTasks200Response {
        val localVarResponse = listTasksWithHttpInfo(status = status, priority = priority, page = page, limit = limit, sortBy = sortBy, sortOrder = sortOrder, search = search)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTasks200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/tasks
     * Get all tasks for the logged-in user
     * 
     * @param status Filtrar por status (optional)
     * @param priority Filtrar por prioridade (optional)
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @param sortBy Campo para ordenação (optional, default to createdAt)
     * @param sortOrder Ordem da classificação (optional, default to desc)
     * @param search Buscar no título e descrição (optional)
     * @return ApiResponse<ListTasks200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTasksWithHttpInfo(status: StatusListTasks?, priority: PriorityListTasks?, page: kotlin.Int?, limit: kotlin.Int?, sortBy: SortByListTasks?, sortOrder: SortOrderListTasks?, search: kotlin.String?) : ApiResponse<ListTasks200Response?> {
        val localVariableConfig = listTasksRequestConfig(status = status, priority = priority, page = page, limit = limit, sortBy = sortBy, sortOrder = sortOrder, search = search)

        return request<Unit, ListTasks200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTasks
     *
     * @param status Filtrar por status (optional)
     * @param priority Filtrar por prioridade (optional)
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @param sortBy Campo para ordenação (optional, default to createdAt)
     * @param sortOrder Ordem da classificação (optional, default to desc)
     * @param search Buscar no título e descrição (optional)
     * @return RequestConfig
     */
    fun listTasksRequestConfig(status: StatusListTasks?, priority: PriorityListTasks?, page: kotlin.Int?, limit: kotlin.Int?, sortBy: SortByListTasks?, sortOrder: SortOrderListTasks?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (priority != null) {
                    put("priority", listOf(priority.value))
                }
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortBy != null) {
                    put("sortBy", listOf(sortBy.value))
                }
                if (sortOrder != null) {
                    put("sortOrder", listOf(sortOrder.value))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/tasks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter status
     */
     enum class StatusListTasksByStatus(val value: kotlin.String) {
         @Json(name = "pending") pending("pending"),
         @Json(name = "in_progress") in_progress("in_progress"),
         @Json(name = "completed") completed("completed");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /api/tasks/status/{status}
     * Get tasks by status
     * 
     * @param status Status das tarefas
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @return ListTasksByStatus200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTasksByStatus(status: StatusListTasksByStatus, page: kotlin.Int? = 1, limit: kotlin.Int? = 10) : ListTasksByStatus200Response {
        val localVarResponse = listTasksByStatusWithHttpInfo(status = status, page = page, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTasksByStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/tasks/status/{status}
     * Get tasks by status
     * 
     * @param status Status das tarefas
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @return ApiResponse<ListTasksByStatus200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTasksByStatusWithHttpInfo(status: StatusListTasksByStatus, page: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<ListTasksByStatus200Response?> {
        val localVariableConfig = listTasksByStatusRequestConfig(status = status, page = page, limit = limit)

        return request<Unit, ListTasksByStatus200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTasksByStatus
     *
     * @param status Status das tarefas
     * @param page Número da página (optional, default to 1)
     * @param limit Itens por página (optional, default to 10)
     * @return RequestConfig
     */
    fun listTasksByStatusRequestConfig(status: StatusListTasksByStatus, page: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (page != null) {
                    put("page", listOf(page.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/tasks/status/{status}".replace("{"+"status"+"}", encodeURIComponent(status.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PUT /api/tasks/{id}
     * Update a task
     * 
     * @param id ID da tarefa
     * @param updateTaskRequest 
     * @return UpdateTask200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTask(id: kotlin.String, updateTaskRequest: UpdateTaskRequest) : UpdateTask200Response {
        val localVarResponse = updateTaskWithHttpInfo(id = id, updateTaskRequest = updateTaskRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateTask200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /api/tasks/{id}
     * Update a task
     * 
     * @param id ID da tarefa
     * @param updateTaskRequest 
     * @return ApiResponse<UpdateTask200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTaskWithHttpInfo(id: kotlin.String, updateTaskRequest: UpdateTaskRequest) : ApiResponse<UpdateTask200Response?> {
        val localVariableConfig = updateTaskRequestConfig(id = id, updateTaskRequest = updateTaskRequest)

        return request<UpdateTaskRequest, UpdateTask200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTask
     *
     * @param id ID da tarefa
     * @param updateTaskRequest 
     * @return RequestConfig
     */
    fun updateTaskRequestConfig(id: kotlin.String, updateTaskRequest: UpdateTaskRequest) : RequestConfig<UpdateTaskRequest> {
        val localVariableBody = updateTaskRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/tasks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
