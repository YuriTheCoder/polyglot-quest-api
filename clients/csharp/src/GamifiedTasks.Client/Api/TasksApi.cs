// <auto-generated>
/*
 * Gamified Task Management API
 *
 * API REST gamificada para gerenciamento de tarefas com IA, XP, levels e sistema de recompensas
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using GamifiedTasks.Client.Client;
using GamifiedTasks.Client.Model;
using System.Diagnostics.CodeAnalysis;

namespace GamifiedTasks.Client.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface ITasksApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        TasksApiEvents Events { get; }

        /// <summary>
        /// Mark a task as complete
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICompleteTaskApiResponse"/>&gt;</returns>
        Task<ICompleteTaskApiResponse> CompleteTaskAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mark a task as complete
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICompleteTaskApiResponse"/>?&gt;</returns>
        Task<ICompleteTaskApiResponse?> CompleteTaskOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a new task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiResponse"/>&gt;</returns>
        Task<ICreateTaskApiResponse> CreateTaskAsync(CreateTaskRequest createTaskRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a new task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="createTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiResponse"/>?&gt;</returns>
        Task<ICreateTaskApiResponse?> CreateTaskOrDefaultAsync(CreateTaskRequest createTaskRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiResponse"/>&gt;</returns>
        Task<IDeleteTaskApiResponse> DeleteTaskAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiResponse"/>?&gt;</returns>
        Task<IDeleteTaskApiResponse?> DeleteTaskOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a specific task by ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskByIdApiResponse"/>&gt;</returns>
        Task<IGetTaskByIdApiResponse> GetTaskByIdAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a specific task by ID
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskByIdApiResponse"/>?&gt;</returns>
        Task<IGetTaskByIdApiResponse?> GetTaskByIdOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get task statistics
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskStatsApiResponse"/>&gt;</returns>
        Task<IGetTaskStatsApiResponse> GetTaskStatsAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get task statistics
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskStatsApiResponse"/>?&gt;</returns>
        Task<IGetTaskStatsApiResponse?> GetTaskStatsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all tasks for the logged-in user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Filtrar por status (optional)</param>
        /// <param name="priority">Filtrar por prioridade (optional)</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="sortBy">Campo para ordenação (optional, default to createdAt)</param>
        /// <param name="sortOrder">Ordem da classificação (optional, default to desc)</param>
        /// <param name="search">Buscar no título e descrição (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksApiResponse"/>&gt;</returns>
        Task<IListTasksApiResponse> ListTasksAsync(Option<string> status = default, Option<string> priority = default, Option<int> page = default, Option<int> limit = default, Option<string> sortBy = default, Option<string> sortOrder = default, Option<string> search = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all tasks for the logged-in user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="status">Filtrar por status (optional)</param>
        /// <param name="priority">Filtrar por prioridade (optional)</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="sortBy">Campo para ordenação (optional, default to createdAt)</param>
        /// <param name="sortOrder">Ordem da classificação (optional, default to desc)</param>
        /// <param name="search">Buscar no título e descrição (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksApiResponse"/>?&gt;</returns>
        Task<IListTasksApiResponse?> ListTasksOrDefaultAsync(Option<string> status = default, Option<string> priority = default, Option<int> page = default, Option<int> limit = default, Option<string> sortBy = default, Option<string> sortOrder = default, Option<string> search = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get tasks by status
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Status das tarefas</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksByStatusApiResponse"/>&gt;</returns>
        Task<IListTasksByStatusApiResponse> ListTasksByStatusAsync(string status, Option<int> page = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get tasks by status
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="status">Status das tarefas</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksByStatusApiResponse"/>?&gt;</returns>
        Task<IListTasksByStatusApiResponse?> ListTasksByStatusOrDefaultAsync(string status, Option<int> page = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="updateTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiResponse"/>&gt;</returns>
        Task<IUpdateTaskApiResponse> UpdateTaskAsync(string id, UpdateTaskRequest updateTaskRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a task
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <param name="id">ID da tarefa</param>
        /// <param name="updateTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiResponse"/>?&gt;</returns>
        Task<IUpdateTaskApiResponse?> UpdateTaskOrDefaultAsync(string id, UpdateTaskRequest updateTaskRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICompleteTaskApiResponse"/>
    /// </summary>
    public interface ICompleteTaskApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.CompleteTask200Response?>, IBadRequest<GamifiedTasks.Client.Model.Error?>, IForbidden<GamifiedTasks.Client.Model.Error?>, INotFound<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="ICreateTaskApiResponse"/>
    /// </summary>
    public interface ICreateTaskApiResponse : GamifiedTasks.Client.Client.IApiResponse, ICreated<GamifiedTasks.Client.Model.CreateTask201Response?>, IBadRequest<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteTaskApiResponse"/>
    /// </summary>
    public interface IDeleteTaskApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.DeleteTask200Response?>, IForbidden<GamifiedTasks.Client.Model.Error?>, INotFound<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetTaskByIdApiResponse"/>
    /// </summary>
    public interface IGetTaskByIdApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.GetTaskById200Response?>, IForbidden<GamifiedTasks.Client.Model.Error?>, INotFound<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// The <see cref="IGetTaskStatsApiResponse"/>
    /// </summary>
    public interface IGetTaskStatsApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.GetTaskStats200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListTasksApiResponse"/>
    /// </summary>
    public interface IListTasksApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.ListTasks200Response?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListTasksByStatusApiResponse"/>
    /// </summary>
    public interface IListTasksByStatusApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.ListTasksByStatus200Response?>, IBadRequest<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }
    }

    /// <summary>
    /// The <see cref="IUpdateTaskApiResponse"/>
    /// </summary>
    public interface IUpdateTaskApiResponse : GamifiedTasks.Client.Client.IApiResponse, IOk<GamifiedTasks.Client.Model.UpdateTask200Response?>, IBadRequest<GamifiedTasks.Client.Model.Error?>, IForbidden<GamifiedTasks.Client.Model.Error?>, INotFound<GamifiedTasks.Client.Model.Error?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class TasksApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCompleteTask;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCompleteTask;

        internal void ExecuteOnCompleteTask(TasksApi.CompleteTaskApiResponse apiResponse)
        {
            OnCompleteTask?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCompleteTask(Exception exception)
        {
            OnErrorCompleteTask?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateTask;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateTask;

        internal void ExecuteOnCreateTask(TasksApi.CreateTaskApiResponse apiResponse)
        {
            OnCreateTask?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateTask(Exception exception)
        {
            OnErrorCreateTask?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteTask;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteTask;

        internal void ExecuteOnDeleteTask(TasksApi.DeleteTaskApiResponse apiResponse)
        {
            OnDeleteTask?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteTask(Exception exception)
        {
            OnErrorDeleteTask?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTaskById;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTaskById;

        internal void ExecuteOnGetTaskById(TasksApi.GetTaskByIdApiResponse apiResponse)
        {
            OnGetTaskById?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTaskById(Exception exception)
        {
            OnErrorGetTaskById?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetTaskStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetTaskStats;

        internal void ExecuteOnGetTaskStats(TasksApi.GetTaskStatsApiResponse apiResponse)
        {
            OnGetTaskStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetTaskStats(Exception exception)
        {
            OnErrorGetTaskStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTasks;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTasks;

        internal void ExecuteOnListTasks(TasksApi.ListTasksApiResponse apiResponse)
        {
            OnListTasks?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTasks(Exception exception)
        {
            OnErrorListTasks?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListTasksByStatus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListTasksByStatus;

        internal void ExecuteOnListTasksByStatus(TasksApi.ListTasksByStatusApiResponse apiResponse)
        {
            OnListTasksByStatus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListTasksByStatus(Exception exception)
        {
            OnErrorListTasksByStatus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUpdateTask;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUpdateTask;

        internal void ExecuteOnUpdateTask(TasksApi.UpdateTaskApiResponse apiResponse)
        {
            OnUpdateTask?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUpdateTask(Exception exception)
        {
            OnErrorUpdateTask?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class TasksApi : ITasksApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<TasksApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public TasksApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="TasksApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TasksApi(ILogger<TasksApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, TasksApiEvents tasksApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<TasksApi>();
            HttpClient = httpClient;
            Events = tasksApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatCompleteTask(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateCompleteTask(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterCompleteTaskDefaultImplementation(ICompleteTaskApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterCompleteTask(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterCompleteTask(ref bool suppressDefaultLog, ICompleteTaskApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorCompleteTaskDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCompleteTask(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorCompleteTask(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Mark a task as complete 
        /// </summary>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICompleteTaskApiResponse"/>&gt;</returns>
        public async Task<ICompleteTaskApiResponse?> CompleteTaskOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CompleteTaskAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Mark a task as complete 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICompleteTaskApiResponse"/>&gt;</returns>
        public async Task<ICompleteTaskApiResponse> CompleteTaskAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCompleteTask(id);

                FormatCompleteTask(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/{id}/complete"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/{id}/complete");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Patch;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CompleteTaskApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CompleteTaskApiResponse>();

                        CompleteTaskApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/{id}/complete", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCompleteTaskDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnCompleteTask(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCompleteTaskDefaultImplementation(e, "/api/tasks/{id}/complete", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorCompleteTask(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CompleteTaskApiResponse"/>
        /// </summary>
        public partial class CompleteTaskApiResponse : GamifiedTasks.Client.Client.ApiResponse, ICompleteTaskApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CompleteTaskApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CompleteTaskApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CompleteTaskApiResponse(ILogger<CompleteTaskApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.CompleteTask200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.CompleteTask200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.CompleteTask200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateTask(CreateTaskRequest createTaskRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createTaskRequest"></param>
        /// <returns></returns>
        private void ValidateCreateTask(CreateTaskRequest createTaskRequest)
        {
            if (createTaskRequest == null)
                throw new ArgumentNullException(nameof(createTaskRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createTaskRequest"></param>
        private void AfterCreateTaskDefaultImplementation(ICreateTaskApiResponse apiResponseLocalVar, CreateTaskRequest createTaskRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateTask(ref suppressDefaultLog, apiResponseLocalVar, createTaskRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createTaskRequest"></param>
        partial void AfterCreateTask(ref bool suppressDefaultLog, ICreateTaskApiResponse apiResponseLocalVar, CreateTaskRequest createTaskRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createTaskRequest"></param>
        private void OnErrorCreateTaskDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateTaskRequest createTaskRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateTask(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createTaskRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createTaskRequest"></param>
        partial void OnErrorCreateTask(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, CreateTaskRequest createTaskRequest);

        /// <summary>
        /// Create a new task 
        /// </summary>
        /// <param name="createTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiResponse"/>&gt;</returns>
        public async Task<ICreateTaskApiResponse?> CreateTaskOrDefaultAsync(CreateTaskRequest createTaskRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateTaskAsync(createTaskRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a new task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateTaskApiResponse"/>&gt;</returns>
        public async Task<ICreateTaskApiResponse> CreateTaskAsync(CreateTaskRequest createTaskRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateTask(createTaskRequest);

                FormatCreateTask(createTaskRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks");

                    httpRequestMessageLocalVar.Content = (createTaskRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createTaskRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateTaskApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateTaskApiResponse>();

                        CreateTaskApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateTaskDefaultImplementation(apiResponseLocalVar, createTaskRequest);

                        Events.ExecuteOnCreateTask(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateTaskDefaultImplementation(e, "/api/tasks", uriBuilderLocalVar.Path, createTaskRequest);
                Events.ExecuteOnErrorCreateTask(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateTaskApiResponse"/>
        /// </summary>
        public partial class CreateTaskApiResponse : GamifiedTasks.Client.Client.ApiResponse, ICreateTaskApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateTaskApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateTaskApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateTaskApiResponse(ILogger<CreateTaskApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.CreateTask201Response? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.CreateTask201Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out GamifiedTasks.Client.Model.CreateTask201Response? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteTask(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateDeleteTask(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteTaskDefaultImplementation(IDeleteTaskApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteTask(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteTask(ref bool suppressDefaultLog, IDeleteTaskApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteTaskDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteTask(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteTask(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Delete a task 
        /// </summary>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiResponse"/>&gt;</returns>
        public async Task<IDeleteTaskApiResponse?> DeleteTaskOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteTaskAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteTaskApiResponse"/>&gt;</returns>
        public async Task<IDeleteTaskApiResponse> DeleteTaskAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDeleteTask(id);

                FormatDeleteTask(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteTaskApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteTaskApiResponse>();

                        DeleteTaskApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteTaskDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteTask(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteTaskDefaultImplementation(e, "/api/tasks/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteTask(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteTaskApiResponse"/>
        /// </summary>
        public partial class DeleteTaskApiResponse : GamifiedTasks.Client.Client.ApiResponse, IDeleteTaskApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteTaskApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteTaskApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteTaskApiResponse(ILogger<DeleteTaskApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.DeleteTask200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.DeleteTask200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.DeleteTask200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetTaskById(ref string id);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        private void ValidateGetTaskById(string id)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetTaskByIdDefaultImplementation(IGetTaskByIdApiResponse apiResponseLocalVar, string id)
        {
            bool suppressDefaultLog = false;
            AfterGetTaskById(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetTaskById(ref bool suppressDefaultLog, IGetTaskByIdApiResponse apiResponseLocalVar, string id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetTaskByIdDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTaskById(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetTaskById(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id);

        /// <summary>
        /// Get a specific task by ID 
        /// </summary>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskByIdApiResponse"/>&gt;</returns>
        public async Task<IGetTaskByIdApiResponse?> GetTaskByIdOrDefaultAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTaskByIdAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a specific task by ID 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskByIdApiResponse"/>&gt;</returns>
        public async Task<IGetTaskByIdApiResponse> GetTaskByIdAsync(string id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetTaskById(id);

                FormatGetTaskById(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTaskByIdApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTaskByIdApiResponse>();

                        GetTaskByIdApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTaskByIdDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetTaskById(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTaskByIdDefaultImplementation(e, "/api/tasks/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetTaskById(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTaskByIdApiResponse"/>
        /// </summary>
        public partial class GetTaskByIdApiResponse : GamifiedTasks.Client.Client.ApiResponse, IGetTaskByIdApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTaskByIdApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTaskByIdApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTaskByIdApiResponse(ILogger<GetTaskByIdApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.GetTaskById200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.GetTaskById200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.GetTaskById200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterGetTaskStatsDefaultImplementation(IGetTaskStatsApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterGetTaskStats(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterGetTaskStats(ref bool suppressDefaultLog, IGetTaskStatsApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorGetTaskStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetTaskStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorGetTaskStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Get task statistics 
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskStatsApiResponse"/>&gt;</returns>
        public async Task<IGetTaskStatsApiResponse?> GetTaskStatsOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetTaskStatsAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get task statistics 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetTaskStatsApiResponse"/>&gt;</returns>
        public async Task<IGetTaskStatsApiResponse> GetTaskStatsAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/stats");

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetTaskStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetTaskStatsApiResponse>();

                        GetTaskStatsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/stats", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetTaskStatsDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnGetTaskStats(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetTaskStatsDefaultImplementation(e, "/api/tasks/stats", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorGetTaskStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetTaskStatsApiResponse"/>
        /// </summary>
        public partial class GetTaskStatsApiResponse : GamifiedTasks.Client.Client.ApiResponse, IGetTaskStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetTaskStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetTaskStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetTaskStatsApiResponse(ILogger<GetTaskStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.GetTaskStats200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.GetTaskStats200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.GetTaskStats200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTasks(ref Option<string> status, ref Option<string> priority, ref Option<int> page, ref Option<int> limit, ref Option<string> sortBy, ref Option<string> sortOrder, ref Option<string> search);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="status"></param>
        /// <param name="priority"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortOrder"></param>
        /// <param name="search"></param>
        /// <returns></returns>
        private void ValidateListTasks(Option<string> status, Option<string> priority, Option<string> sortBy, Option<string> sortOrder, Option<string> search)
        {
            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (priority.IsSet && priority.Value == null)
                throw new ArgumentNullException(nameof(priority));

            if (sortBy.IsSet && sortBy.Value == null)
                throw new ArgumentNullException(nameof(sortBy));

            if (sortOrder.IsSet && sortOrder.Value == null)
                throw new ArgumentNullException(nameof(sortOrder));

            if (search.IsSet && search.Value == null)
                throw new ArgumentNullException(nameof(search));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="priority"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortOrder"></param>
        /// <param name="search"></param>
        private void AfterListTasksDefaultImplementation(IListTasksApiResponse apiResponseLocalVar, Option<string> status, Option<string> priority, Option<int> page, Option<int> limit, Option<string> sortBy, Option<string> sortOrder, Option<string> search)
        {
            bool suppressDefaultLog = false;
            AfterListTasks(ref suppressDefaultLog, apiResponseLocalVar, status, priority, page, limit, sortBy, sortOrder, search);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="priority"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortOrder"></param>
        /// <param name="search"></param>
        partial void AfterListTasks(ref bool suppressDefaultLog, IListTasksApiResponse apiResponseLocalVar, Option<string> status, Option<string> priority, Option<int> page, Option<int> limit, Option<string> sortBy, Option<string> sortOrder, Option<string> search);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="priority"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortOrder"></param>
        /// <param name="search"></param>
        private void OnErrorListTasksDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> priority, Option<int> page, Option<int> limit, Option<string> sortBy, Option<string> sortOrder, Option<string> search)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTasks(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, status, priority, page, limit, sortBy, sortOrder, search);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="priority"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortOrder"></param>
        /// <param name="search"></param>
        partial void OnErrorListTasks(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> priority, Option<int> page, Option<int> limit, Option<string> sortBy, Option<string> sortOrder, Option<string> search);

        /// <summary>
        /// Get all tasks for the logged-in user 
        /// </summary>
        /// <param name="status">Filtrar por status (optional)</param>
        /// <param name="priority">Filtrar por prioridade (optional)</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="sortBy">Campo para ordenação (optional, default to createdAt)</param>
        /// <param name="sortOrder">Ordem da classificação (optional, default to desc)</param>
        /// <param name="search">Buscar no título e descrição (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksApiResponse"/>&gt;</returns>
        public async Task<IListTasksApiResponse?> ListTasksOrDefaultAsync(Option<string> status = default, Option<string> priority = default, Option<int> page = default, Option<int> limit = default, Option<string> sortBy = default, Option<string> sortOrder = default, Option<string> search = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTasksAsync(status, priority, page, limit, sortBy, sortOrder, search, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all tasks for the logged-in user 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Filtrar por status (optional)</param>
        /// <param name="priority">Filtrar por prioridade (optional)</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="sortBy">Campo para ordenação (optional, default to createdAt)</param>
        /// <param name="sortOrder">Ordem da classificação (optional, default to desc)</param>
        /// <param name="search">Buscar no título e descrição (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksApiResponse"/>&gt;</returns>
        public async Task<IListTasksApiResponse> ListTasksAsync(Option<string> status = default, Option<string> priority = default, Option<int> page = default, Option<int> limit = default, Option<string> sortBy = default, Option<string> sortOrder = default, Option<string> search = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListTasks(status, priority, sortBy, sortOrder, search);

                FormatListTasks(ref status, ref priority, ref page, ref limit, ref sortBy, ref sortOrder, ref search);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (priority.IsSet)
                        parseQueryStringLocalVar["priority"] = ClientUtils.ParameterToString(priority.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (sortBy.IsSet)
                        parseQueryStringLocalVar["sortBy"] = ClientUtils.ParameterToString(sortBy.Value);

                    if (sortOrder.IsSet)
                        parseQueryStringLocalVar["sortOrder"] = ClientUtils.ParameterToString(sortOrder.Value);

                    if (search.IsSet)
                        parseQueryStringLocalVar["search"] = ClientUtils.ParameterToString(search.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListTasksApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTasksApiResponse>();

                        ListTasksApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListTasksDefaultImplementation(apiResponseLocalVar, status, priority, page, limit, sortBy, sortOrder, search);

                        Events.ExecuteOnListTasks(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTasksDefaultImplementation(e, "/api/tasks", uriBuilderLocalVar.Path, status, priority, page, limit, sortBy, sortOrder, search);
                Events.ExecuteOnErrorListTasks(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTasksApiResponse"/>
        /// </summary>
        public partial class ListTasksApiResponse : GamifiedTasks.Client.Client.ApiResponse, IListTasksApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTasksApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTasksApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTasksApiResponse(ILogger<ListTasksApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.ListTasks200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.ListTasks200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.ListTasks200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListTasksByStatus(ref string status, ref Option<int> page, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListTasksByStatus(string status)
        {
            if (status == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        private void AfterListTasksByStatusDefaultImplementation(IListTasksByStatusApiResponse apiResponseLocalVar, string status, Option<int> page, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterListTasksByStatus(ref suppressDefaultLog, apiResponseLocalVar, status, page, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        partial void AfterListTasksByStatus(ref bool suppressDefaultLog, IListTasksByStatusApiResponse apiResponseLocalVar, string status, Option<int> page, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        private void OnErrorListTasksByStatusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string status, Option<int> page, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListTasksByStatus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, status, page, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="limit"></param>
        partial void OnErrorListTasksByStatus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string status, Option<int> page, Option<int> limit);

        /// <summary>
        /// Get tasks by status 
        /// </summary>
        /// <param name="status">Status das tarefas</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksByStatusApiResponse"/>&gt;</returns>
        public async Task<IListTasksByStatusApiResponse?> ListTasksByStatusOrDefaultAsync(string status, Option<int> page = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListTasksByStatusAsync(status, page, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get tasks by status 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Status das tarefas</param>
        /// <param name="page">Número da página (optional, default to 1)</param>
        /// <param name="limit">Itens por página (optional, default to 10)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListTasksByStatusApiResponse"/>&gt;</returns>
        public async Task<IListTasksByStatusApiResponse> ListTasksByStatusAsync(string status, Option<int> page = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListTasksByStatus(status);

                FormatListTasksByStatus(ref status, ref page, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/status/{status}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/status/{status}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bstatus%7D", Uri.EscapeDataString(status.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListTasksByStatusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListTasksByStatusApiResponse>();

                        ListTasksByStatusApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/status/{status}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListTasksByStatusDefaultImplementation(apiResponseLocalVar, status, page, limit);

                        Events.ExecuteOnListTasksByStatus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListTasksByStatusDefaultImplementation(e, "/api/tasks/status/{status}", uriBuilderLocalVar.Path, status, page, limit);
                Events.ExecuteOnErrorListTasksByStatus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListTasksByStatusApiResponse"/>
        /// </summary>
        public partial class ListTasksByStatusApiResponse : GamifiedTasks.Client.Client.ApiResponse, IListTasksByStatusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListTasksByStatusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListTasksByStatusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListTasksByStatusApiResponse(ILogger<ListTasksByStatusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.ListTasksByStatus200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.ListTasksByStatus200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.ListTasksByStatus200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUpdateTask(ref string id, UpdateTaskRequest updateTaskRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="id"></param>
        /// <param name="updateTaskRequest"></param>
        /// <returns></returns>
        private void ValidateUpdateTask(string id, UpdateTaskRequest updateTaskRequest)
        {
            if (id == null)
                throw new ArgumentNullException(nameof(id));

            if (updateTaskRequest == null)
                throw new ArgumentNullException(nameof(updateTaskRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateTaskRequest"></param>
        private void AfterUpdateTaskDefaultImplementation(IUpdateTaskApiResponse apiResponseLocalVar, string id, UpdateTaskRequest updateTaskRequest)
        {
            bool suppressDefaultLog = false;
            AfterUpdateTask(ref suppressDefaultLog, apiResponseLocalVar, id, updateTaskRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateTaskRequest"></param>
        partial void AfterUpdateTask(ref bool suppressDefaultLog, IUpdateTaskApiResponse apiResponseLocalVar, string id, UpdateTaskRequest updateTaskRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateTaskRequest"></param>
        private void OnErrorUpdateTaskDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, UpdateTaskRequest updateTaskRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUpdateTask(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, updateTaskRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="updateTaskRequest"></param>
        partial void OnErrorUpdateTask(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string id, UpdateTaskRequest updateTaskRequest);

        /// <summary>
        /// Update a task 
        /// </summary>
        /// <param name="id">ID da tarefa</param>
        /// <param name="updateTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiResponse"/>&gt;</returns>
        public async Task<IUpdateTaskApiResponse?> UpdateTaskOrDefaultAsync(string id, UpdateTaskRequest updateTaskRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UpdateTaskAsync(id, updateTaskRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a task 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID da tarefa</param>
        /// <param name="updateTaskRequest"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUpdateTaskApiResponse"/>&gt;</returns>
        public async Task<IUpdateTaskApiResponse> UpdateTaskAsync(string id, UpdateTaskRequest updateTaskRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateUpdateTask(id, updateTaskRequest);

                FormatUpdateTask(ref id, updateTaskRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/api/tasks/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/api/tasks/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    httpRequestMessageLocalVar.Content = (updateTaskRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(updateTaskRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UpdateTaskApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UpdateTaskApiResponse>();

                        UpdateTaskApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/api/tasks/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUpdateTaskDefaultImplementation(apiResponseLocalVar, id, updateTaskRequest);

                        Events.ExecuteOnUpdateTask(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUpdateTaskDefaultImplementation(e, "/api/tasks/{id}", uriBuilderLocalVar.Path, id, updateTaskRequest);
                Events.ExecuteOnErrorUpdateTask(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UpdateTaskApiResponse"/>
        /// </summary>
        public partial class UpdateTaskApiResponse : GamifiedTasks.Client.Client.ApiResponse, IUpdateTaskApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UpdateTaskApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UpdateTaskApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UpdateTaskApiResponse(ILogger<UpdateTaskApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.UpdateTask200Response? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.UpdateTask200Response>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out GamifiedTasks.Client.Model.UpdateTask200Response? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public GamifiedTasks.Client.Model.Error? NotFound()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsNotFound
                    ? System.Text.Json.JsonSerializer.Deserialize<GamifiedTasks.Client.Model.Error>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 404 NotFound and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryNotFound([NotNullWhen(true)]out GamifiedTasks.Client.Model.Error? result)
            {
                result = null;

                try
                {
                    result = NotFound();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)404);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
